use ::tetron::log;
use tetron::config;
use tetron::{game::{drawable, physics, physics::vec2, transform, shape}, input};

const BALL_RADIUS = 5;
const PADDLE_W = 80;
const PADDLE_H = 10;
const BRICK_W = 60;
const BRICK_H = 20;
const WALL_COLOR = "#333";
const BRICK_COLOR = "#ff6600";

fn Ball(scene, x, y) {
    let ball = scene.spawn();
    ball.attach(shape::create("circle", #{ r: BALL_RADIUS })?);
    ball.attach(physics::create(#{ collision: "simulate" })?);
    ball.attach(transform::create(#{ pos: vec2(x, y) })?);
    ball.attach(drawable::create(#{ color: "#ffffff" })?);
    ball.tag("player");
}

fn Wall(scene, x, y, w, h) {
    let wall = scene.spawn();
    wall.attach(shape::create("rect", #{ w, h })?);
    wall.attach(drawable::create(#{ color: WALL_COLOR })?);
    wall.attach(physics::create(#{ immovable: true })?);
    wall.attach(transform::create(#{ pos: vec2(x, y) })?);
}

fn Brick(scene, x, y) {
    let brick = scene.spawn();
    brick.attach(shape::create("rect", #{ w: BRICK_W, h: BRICK_H })?);
    brick.attach(drawable::create(#{ color: BRICK_COLOR })?);
    brick.attach(physics::create(#{ immovable: true })?);
    brick.attach(transform::create(#{ pos: vec2(x, y) })?);
}

fn out_of_bounds_system(ctx, _dt) {
    for ball in ctx.query(#{ tag: ["ball"] }) {
        let pos = ball.behaviour("tetron:physics")?.pos;
        if (pos.y >= 480) {
            ctx.world.load_scene("game_over");
        }
    }
}

fn paddle_input_system(ctx, _dt) {
    for ent in ctx.query(#{ tag: ["paddle"] }) {
        let b = ent.behaviour("tetron:physics")?;
        if (input::just_released("KeyRight")) {
            physics::apply_force(b, #{ x: 1, y: 0 });
        } else if (input::is_down("KeyLeft")) {
            physics::apply_force(b, #{ x: -1, y: 0 });
        } else {
            b.vel.x = 0;
        }
    }
}

fn Paddle(scene, x, y) {
    let paddle = scene.spawn();
    paddle.tag("paddle");
    paddle.attach(shape::create("rect", #{ w: PADDLE_W, h: PADDLE_H })?);
    paddle.attach(drawable::create(#{ color: "#007cdf" })?);
    paddle.attach(physics::create(#{ friction: 0.8, collision: "immovable" })?);
    paddle.attach(transform::create(#{ pos: vec2(x, y) })?);
}

fn setup_game_scene(world) {
    let scene = world.scene("game", #{ bg: "#120321", gravity: vec2(0.0, 0.0) })?;

    Paddle(scene, 320, 460);
    Ball(scene, 320, 240);
    Wall(scene, 0, 0, 640, 10);
    Wall(scene, 0, 0, 10, 480);
    Wall(scene, 630, 0, 10, 480);
    for row in 0..5 {
        for col in 0..10 {
            let x = 20 + col * (BRICK_W + 2);
            let y = 40 + row * (BRICK_H + 2);
            Brick(scene, x, y);
        }
    }
    scene.system("input", paddle_input_system);
    scene.system("out-of-bounds", out_of_bounds_system);
}

fn menu_input_system(ctx, _dt) {
    if (input::just_released("Space")) {
        ctx.world.load_scene("main");
    }
}

fn setup_menu_scene(world) {
    let scene = world.scene("menu", #{ bg: "#000000" })?;

    let label = scene.spawn();
    label.attach(drawable::create(#{ text: "Press SPACE to Start", size: 24, color: "#ffffff" })?);
    label.attach(transform::create(#{ x: 200, y: 220 })?);

    scene.system("update", menu_input_system);
}

fn game_over_input_system(ctx, _dt) {
    if (input::just_released("r")) {
        ctx.world.load_scene("main");
    }
}

fn game_over_scene(world) {
    let scene = world.scene("game_over", #{ bg: "#120321" })?;

    let label = scene.spawn();
    label.attach(transform::create(#{ x: 240, y: 200 })?);
    label.attach(drawable::create(#{ text: "Game Over", font: #{ size: 32 }, color: "#ff0000" })?);

    let prompt = scene.spawn();
    prompt.attach(drawable::create(#{ text: "Press R to Restart", font: #{ size: 20 }, color: "#ffffff" })?);
    prompt.attach(transform::create(#{ x: 230, y: 260 })?);

    scene.system("update", game_over_input_system);
}

pub fn begin(world) {
    if let Some(identifier) = config::get(["identifier"])? {
        log::info!(`Running example ${identifier}`);
    }

    setup_game_scene(world);
    setup_menu_scene(world);
    game_over_scene(world);

    world.load_scene("menu");
}
