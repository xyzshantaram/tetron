use tetron::{game::{drawable, physics, transform, shape}, input};
use ::tetron::log::log_info;

const BALL_RADIUS = 5;
const PADDLE_W = 80;
const PADDLE_H = 10;
const BRICK_W = 60;
const BRICK_H = 20;
const WALL_COLOR = "#333";
const BRICK_COLOR = "#ff6600";

fn Ball(scene, x, y) {
    let ball = scene.spawn();
    ball.attach(shape("circle", #{ r: BALL_RADIUS }));
    ball.attach(physics(#{ collision: "simulate" }));
    ball.attach(transform(#{ x, y }));
    ball.attach(drawable(#{ color: "#ffffff" }));
    ball.tag("player");
    return ball;
}

fn Wall(scene, x, y, w, h) {
    let wall = scene.spawn();
    wall.attach(shape("rect", #{ w, h }));
    wall.attach(drawable(#{ color: WALL_COLOR }));
    wall.attach(physics(#{ immovable: true }));
    wall.attach(transform(#{ x, y }));
    return wall;
}

fn Brick(scene, x, y) {
    let brick = scene.spawn();
    brick.attach(shape("rect", #{ w: BRICK_W, h: BRICK_H }));
    brick.attach(drawable(#{ color: BRICK_COLOR }));
    brick.attach(physics(#{ immovable: true }));
    brick.attach(transform(#{ x, y }));
    return brick;
}

// Rust-defined System: Checks if ball goes off screen
fn out_of_bounds_system(ctx, _dt) {
    for ball in ctx.query().with_tag("ball") {
        let pos = ctx.entity(ball).component("tetron:physics").pos;
        if (pos.y > 480) {
            ctx.world.load_scene("game_over");
        }
    }
}

fn paddle_input_system(ctx, _dt) {
    for ent in ctx.query().with_tag("paddle") {
        let phys = ent.component("tetron:physics");
        if (input.key("right")) {
            phys.apply_force(#{ x: 1, y: 0 });
        } else if (input.key("left")) {
            phys.apply_force(#{ x: -1, y: 0 });
        } else {
            phys.vel.x = 0;
        }
    }
}

fn Paddle(scene, x, y) {
    let paddle = scene.spawn();
    paddle.tag("paddle");
    paddle.attach(shape("rect", #{ w: PADDLE_W, h: PADDLE_H }));
    paddle.attach(drawable(#{ color: "#007cdf" }));
    paddle.attach(physics(#{ friction: 0.8, collision: "immovable" }));
    paddle.attach(transform(#{ x, y }));
    return paddle;
}

fn game_scene(world) {
    let scene = world.scene(#{ bg: "#120321", gravity: #{ x: 0, y: 0 } });

    scene.insert(Paddle(scene, 320, 460));
    scene.insert(Ball(scene, 320, 240, 2, -3));

    scene.insert(Wall(scene, 0, 0, 640, 10));
    scene.insert(Wall(scene, 0, 0, 10, 480));
    scene.insert(Wall(scene, 630, 0, 10, 480));

    for row in 0..5 {
        for col in 0..10 {
            let x = 20 + col * (BRICK_W + 2);
            let y = 40 + row * (BRICK_H + 2);
            scene.insert(Brick(scene, x, y));
        }
    }

    scene.system("input", paddle_input_system);
    scene.system("out-of-bounds", out_of_bounds_system);
}

fn menu_input_system(ctx, _dt) {
    if (input.key_down("space")) {
        ctx.world.load_scene("main");
    }
}

fn menu_scene(world) {
    let scene = world.scene(#{ bg: "#000000" });

    let label = scene.spawn();
    label.attach(
        drawable::text(#{ text: "Press SPACE to Start", size: 24, color: "#ffffff", x: 200, y: 220 }),
    );

    scene.system("update", menu_input_system);
}

fn game_over_input_system(ctx, _dt) {
    if (input.key_down("r")) {
        ctx.world.load_scene("main");
    }
}

fn game_over_scene(world) {
    let scene = world.scene(#{ bg: "#120321" });

    let label = scene.spawn();
    label.attach(drawable(#{ text: "Game Over", font: #{ size: 32 }, color: "#ff0000" }));
    label.attach(transform(#{ x: 240, y: 200 }));

    let prompt = scene.spawn();
    prompt.attach(drawable(#{ text: "Press R to Restart", font: #{ size: 20 }, color: "#ffffff" }));
    prompt.attach(transform(#{ x: 230, y: 260 }));

    scene.system("update", game_over_input_system);
}

pub fn begin(world) {
    log_info!("running game breakout");
    world.insert("main", game_scene(world));
    world.insert("menu", menu_scene(world));
    world.insert("game_over", game_over_scene(world));

    world.load_scene("menu");
}
